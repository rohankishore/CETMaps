<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GeoJSON â†’ Custom Campus Map</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    html, body {
      margin: 0;
      height: 100%;
    }
    #map {
      height: 100%;
    }
  </style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* =========================
   MAP INIT
========================= */

const map = L.map("map").setView([8.5452, 76.9364], 17);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 20
}).addTo(map);

/* =========================
   LOAD GEOJSON
========================= */

fetch("data/cet_loc_v1.geojson")
  .then(r => r.json())
  .then(data => {
    drawGeoJSON(data);
    buildAndRoute(data);
  });

/* =========================
   DRAW EVERYTHING
========================= */

function drawGeoJSON(data) {
  L.geoJSON(data, {
    style: f => {
      if (f.geometry.type === "LineString") {
        return { color: "#aaa", weight: 3 };
      }
      if (f.geometry.type.includes("Polygon")) {
        return { color: "#444", fillOpacity: 0.2 };
      }
    }
  }).addTo(map);
}

/* =========================
   BUILD GRAPH + ROUTE
========================= */

function buildAndRoute(geojson) {
  const walkables = geojson.features.filter(f =>
    f.geometry.type === "LineString" &&
    f.properties &&
    ["footway", "path", "pedestrian"].includes(f.properties.highway)
  );

  const nodes = new Map();
  const graph = {};

  function id(lat, lon) {
    return lat + "," + lon;
  }

  function addEdge(a, b, d) {
    graph[a] ??= [];
    graph[b] ??= [];
    graph[a].push([b, d]);
    graph[b].push([a, d]);
  }

  walkables.forEach(f => {
    const coords = f.geometry.coordinates;

    for (let i = 0; i < coords.length - 1; i++) {
      const [lon1, lat1] = coords[i];
      const [lon2, lat2] = coords[i + 1];

      const A = id(lat1, lon1);
      const B = id(lat2, lon2);

      nodes.set(A, [lat1, lon1]);
      nodes.set(B, [lat2, lon2]);

      const d = haversine(lat1, lon1, lat2, lon2);
      addEdge(A, B, d);
    }
  });

  const keys = [...nodes.keys()];
  if (keys.length < 2) return;

  const start = keys[0];
  const end = keys[keys.length - 1];

  const path = dijkstra(graph, start, end);
  drawRoute(path, nodes);
}

/* =========================
   DIJKSTRA
========================= */

function dijkstra(graph, start, end) {
  const dist = {};
  const prev = {};
  const q = new Set(Object.keys(graph));

  q.forEach(n => dist[n] = Infinity);
  dist[start] = 0;

  while (q.size) {
    let u = null;
    q.forEach(n => {
      if (u === null || dist[n] < dist[u]) u = n;
    });

    q.delete(u);
    if (u === end) break;

    (graph[u] || []).forEach(([v, w]) => {
      const alt = dist[u] + w;
      if (alt < dist[v]) {
        dist[v] = alt;
        prev[v] = u;
      }
    });
  }

  const path = [];
  let u = end;
  while (u) {
    path.unshift(u);
    u = prev[u];
  }
  return path;
}

/* =========================
   DRAW ROUTE
========================= */

function drawRoute(path, nodes) {
  const latlngs = path.map(k => nodes.get(k));
  L.polyline(latlngs, {
    color: "red",
    weight: 5
  }).addTo(map);

  map.fitBounds(latlngs);
}

/* =========================
   DISTANCE
========================= */

function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const toRad = x => x * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);

  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) *
    Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) ** 2;

  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
</script>

</body>
</html>
